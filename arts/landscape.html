<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jade Landscape | Procedural Ink</title>
  <meta name="description" content="Generate atmospheric ink-style landscapes with toggles for rain, snow, and seasonal color washes." />
  <link rel="icon" href="../img/logo.png" type="image/png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Inter:wght@300;400;600;700&family=Manrope:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            display: ['Manrope', 'Inter', 'system-ui', 'sans-serif'],
            body: ['Inter', 'system-ui', 'sans-serif'],
            script: ['Ma Shan Zheng', 'serif'],
          },
          colors: {
            obsidian: '#0f1729',
            jade: '#0f766e',
            fog: '#e2e8f0',
          }
        }
      }
    };
  </script>
  <style>
    body {
      background: radial-gradient(circle at 20% 20%, rgba(15, 118, 110, 0.25), transparent 40%),
                  radial-gradient(circle at 80% 10%, rgba(226, 232, 240, 0.35), transparent 35%),
                  linear-gradient(145deg, #0b1020 0%, #0f1729 35%, #0e1a24 100%);
      color: #e2e8f0;
      min-height: 100vh;
    }
    .glass-panel {
      backdrop-filter: blur(10px);
      background: rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }
  </style>
  <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="font-body">
  <div class="max-w-7xl mx-auto px-6 py-10">
    <header class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-8">
      <div>
        <p class="text-sm uppercase tracking-[0.25em] text-slate-300">Ink sketch</p>
        <h1 class="text-4xl sm:text-5xl font-display font-semibold tracking-tight">Jade Landscape</h1>
        <p class="text-slate-300 mt-3 max-w-2xl">Procedural mountain layers inspired by 青绿山水. Toggle weather, seasonal palettes, and export high-resolution frames.</p>
      </div>
      <a href="../index.html" class="inline-flex items-center justify-center gap-2 px-4 py-2 rounded-full border border-slate-500 text-sm text-fog hover:border-jade hover:text-white transition">
        <span class="inline-block w-2 h-2 bg-jade rounded-full animate-pulse"></span>
        Back to More
      </a>
    </header>

    <main class="grid lg:grid-cols-[1fr] gap-6">
      <section class="glass-panel rounded-2xl shadow-2xl overflow-hidden">
        <div id="root"></div>
      </section>
      <section class="glass-panel rounded-2xl shadow-xl p-6">
        <div class="flex items-center gap-3 mb-4">
          <span class="inline-flex items-center justify-center w-10 h-10 rounded-full bg-jade/20 border border-jade text-jade font-display text-xl">i</span>
          <div>
            <p class="text-lg font-display font-semibold">How to play</p>
            <p class="text-sm text-slate-300">Change effects, seasons, and press Randomize to redraw new terrains. Save downloads the current canvas.</p>
          </div>
        </div>
        <ul class="space-y-2 text-sm text-slate-200 leading-relaxed">
          <li>• Rain/Snow add animated particles and tint the sky.</li>
          <li>• Seasons overlay subtle color grading (Spring/Autumn/Winter).</li>
          <li>• Randomize rebuilds terrain layers for new silhouettes.</li>
          <li>• Save captures the canvas at 1024×720 as a PNG.</li>
        </ul>
      </section>
    </main>
  </div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const PALETTE = {
      SKY: ['#E6E2D6', '#D9D2C5'],
      MIST: 'rgba(225, 222, 215, 0.85)',
      LAYERS: ['#BCCCD1','#A5B8BD','#8EA4A9','#779095','#607C81','#49686D','#325459','#1B4045','#042C31'],
      RIVER_WASH: 'rgba(190, 225, 235, 0.6)',
      SNOW: 'rgba(240, 240, 240, 0.9)',
      RAIN: 'rgba(60, 70, 80, 0.6)'
    };

    const WIDTH = 1024;
    const HEIGHT = 720;

    const hexToRgba = (hex, alpha) => {
      let r = 0, g = 0, b = 0;
      if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      } else if (hex.length === 7) {
        r = parseInt(hex.slice(1, 3), 16);
        g = parseInt(hex.slice(3, 5), 16);
        b = parseInt(hex.slice(5, 7), 16);
      }
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const LandscapeCanvas = React.memo(({ activeEffect, activeSeason, generationKey }) => {
      const canvasRef = useRef(null);
      const animationIntervalRef = useRef(null);
      const landscapeDataRef = useRef(null);
      const particlesRef = useRef([]);
      const paperTextureRef = useRef(null);

      const generateLandscapeData = useCallback(() => {
        const layers = [];
        const layerCount = PALETTE.LAYERS.length;
        const mistBlobs = [];

        for (let i = 0; i < layerCount; i++) {
          const mountains = [];
          const progress = i / (layerCount - 1);
          const baseY = HEIGHT * (0.3 + progress * 0.7);
          let currentX = -200;
          while (currentX < WIDTH + 200) {
            const width = 200 + Math.random() * 400;
            const height = (HEIGHT * 0.15) + Math.random() * (HEIGHT * 0.3) * (0.5 + progress * 0.8);
            const m = {
              x: currentX + width / 2,
              y: baseY,
              w: width,
              h: height,
              peakShift: (Math.random() - 0.5) * 0.2,
              smoothness: 0.6 + Math.random() * 0.3,
              shoulderLeft: 0.4 + Math.random() * 0.2,
              shoulderRight: 0.4 + Math.random() * 0.2,
              roughness: Array(6).fill(0).map(() => (Math.random() - 0.5) * 0.05)
            };
            mountains.push(m);
            currentX += width * (0.3 + Math.random() * 0.3);
          }

          layers.push({
            color: PALETTE.LAYERS[i],
            mountains,
            baseY,
            opacity: 0.6 + (progress * 0.4)
          });

          // Precompute mist blobs per layer to avoid per-frame randomness
          const blobs = [];
          for (let m = 0; m < 3; m++) {
            blobs.push({
              cx: Math.random() * WIDTH,
              cy: (baseY - 150) + Math.random() * 50,
              r: 100 + Math.random() * 100
            });
          }
          mistBlobs.push(blobs);
        }

        const riverPoints = [
          { x: WIDTH * 0.4, y: HEIGHT * 0.45 },
          { x: WIDTH * 0.7, y: HEIGHT * 0.6 },
          { x: WIDTH * 0.2, y: HEIGHT * 0.8 },
          { x: WIDTH * 0.6, y: HEIGHT + 200 }
        ];

        return { layers, riverPoints, mistBlobs };
      }, []);

      const drawSingleMountain = useCallback((ctx, m, color, globalAlpha) => {
        ctx.save();
        ctx.globalAlpha = globalAlpha;

        const leftBaseX = m.x - m.w / 2;
        const rightBaseX = m.x + m.w / 2;
        const peakX = m.x + (m.w * m.peakShift);
        const peakY = m.y - m.h;

        const r = m.roughness;
        const jitter = m.w * 0.05;

        ctx.beginPath();
        ctx.moveTo(leftBaseX, m.y);

        ctx.bezierCurveTo(
          leftBaseX + m.w * (0.3 + m.smoothness * 0.1) + r[0]*jitter, m.y - m.h * m.shoulderLeft * m.smoothness,
          peakX - m.w * (0.15 - m.smoothness * 0.05) + r[1]*jitter, peakY + m.h * (0.2 + m.smoothness * 0.1),
          peakX, peakY
        );

        ctx.bezierCurveTo(
          peakX + m.w * (0.15 - m.smoothness * 0.05) + r[2]*jitter, peakY + m.h * (0.2 + m.smoothness * 0.1),
          rightBaseX - m.w * (0.3 + m.smoothness * 0.1) + r[3]*jitter, m.y - m.h * m.shoulderRight * m.smoothness,
          rightBaseX, m.y
        );

        ctx.closePath();

        ctx.shadowColor = hexToRgba(color, 0.5);
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 5;

        const grad = ctx.createLinearGradient(0, peakY, 0, m.y);
        grad.addColorStop(0, hexToRgba(color, 0.95));
        grad.addColorStop(1, hexToRgba(color, 1.0));
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        ctx.globalCompositeOperation = 'source-atop';
        ctx.globalAlpha = globalAlpha * 0.15;
        ctx.fillStyle = '#001015';

        const bands = 4;
        for (let b = 1; b <= bands; b++) {
          const bandYRatio = b / (bands + 1.2);
          const bandY = m.y - m.h * bandYRatio * 0.85;
          ctx.beginPath();
          ctx.moveTo(leftBaseX - 20, m.y + 50);
          ctx.quadraticCurveTo(peakX + r[4]*30, bandY + r[5]*20, rightBaseX + 20, m.y + 50);
          ctx.fill();
        }

        ctx.restore();
      }, []);

      const drawRiver = useCallback((ctx, points) => {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.bezierCurveTo(points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y);

        const grad = ctx.createLinearGradient(0, points[0].y, 0, HEIGHT);
        grad.addColorStop(0, hexToRgba(PALETTE.RIVER_WASH, 0.0));
        grad.addColorStop(0.4, hexToRgba(PALETTE.RIVER_WASH, 0.8));
        grad.addColorStop(1, hexToRgba(PALETTE.RIVER_WASH, 0.2));

        ctx.lineCap = 'round';
        ctx.lineWidth = 300;
        ctx.strokeStyle = grad;
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowColor = hexToRgba(PALETTE.RIVER_WASH, 0.8);
        ctx.shadowBlur = 20;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();
      }, []);

      const drawPaperTexture = useCallback((ctx) => {
        if (!paperTextureRef.current) {
          const offscreen = document.createElement('canvas');
          offscreen.width = WIDTH;
          offscreen.height = HEIGHT;
          const tctx = offscreen.getContext('2d');
          for (let i = 0; i < 5000; i++) {
            tctx.fillStyle = Math.random() > 0.5 ? '#FFF' : '#000';
            tctx.beginPath();
            tctx.arc(Math.random() * WIDTH, Math.random() * HEIGHT, Math.random() * 1.5, 0, Math.PI * 2);
            tctx.fill();
          }
          paperTextureRef.current = offscreen;
        }
        ctx.save();
        ctx.globalCompositeOperation = 'overlay';
        ctx.globalAlpha = 0.08;
        ctx.drawImage(paperTextureRef.current, 0, 0);
        ctx.restore();
      }, []);

      const drawScene = useCallback((ctx) => {
        const { layers, riverPoints, mistBlobs } = landscapeDataRef.current;

        let skyTop = PALETTE.SKY[0];
        let skyBot = PALETTE.SKY[1];

        if (activeEffect === 'rain') {
          skyTop = '#6A7A82';
          skyBot = '#8AA0A8';
        } else if (activeEffect === 'snow') {
          skyTop = '#D5DCE0';
          skyBot = '#EEF2F4';
        }

        const skyGrad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        skyGrad.addColorStop(0, skyTop);
        skyGrad.addColorStop(1, skyBot);
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        if (!activeEffect) {
          ctx.fillStyle = 'rgba(255, 255, 245, 0.25)';
          ctx.beginPath();
          ctx.arc(WIDTH * 0.8, HEIGHT * 0.18, 50, 0, Math.PI * 2);
          ctx.fill();
        }

        layers.forEach((layer, index) => {
          if (index === 5) {
            drawRiver(ctx, riverPoints);
          }

          if (index > 0) {
            const mistY = layer.baseY - 150;
            let mistColor = PALETTE.MIST;
            if (activeEffect === 'rain') mistColor = 'rgba(180, 190, 200, 0.6)';
            if (activeEffect === 'snow') mistColor = 'rgba(240, 245, 250, 0.8)';

            mistBlobs[index]?.forEach((blob) => {
              const cloudGrad = ctx.createRadialGradient(blob.cx, blob.cy, 0, blob.cx, blob.cy, blob.r);
              cloudGrad.addColorStop(0, mistColor);
              cloudGrad.addColorStop(1, 'rgba(255,255,255,0)');
              ctx.fillStyle = cloudGrad;
              ctx.beginPath();
              ctx.arc(blob.cx, blob.cy, blob.r, 0, Math.PI * 2);
              ctx.fill();
            });

            const mistGrad = ctx.createLinearGradient(0, layer.baseY - 100, 0, layer.baseY);
            mistGrad.addColorStop(0, 'rgba(255,255,255,0)');
            mistGrad.addColorStop(0.7, mistColor);
            mistGrad.addColorStop(1, 'rgba(255,255,255,0.1)');
            ctx.fillStyle = mistGrad;
            ctx.fillRect(0, layer.baseY - 150, WIDTH, 250);
          }

          layer.mountains.forEach(m => {
            drawSingleMountain(ctx, m, layer.color, layer.opacity);
          });
        });

        drawPaperTexture(ctx);

        if (activeEffect === 'rain') {
          ctx.save();
          const rainGrad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
          rainGrad.addColorStop(0, 'rgba(40, 60, 70, 0.18)');
          rainGrad.addColorStop(1, 'rgba(10, 16, 24, 0.28)');
          ctx.globalCompositeOperation = 'soft-light';
          ctx.fillStyle = rainGrad;
          ctx.fillRect(0, 0, WIDTH, HEIGHT);
          ctx.restore();
        } else if (activeEffect === 'snow') {
          ctx.save();
          const snowGrad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
          snowGrad.addColorStop(0, 'rgba(245, 250, 255, 0.35)');
          snowGrad.addColorStop(1, 'rgba(210, 220, 230, 0.22)');
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = snowGrad;
          ctx.fillRect(0, 0, WIDTH, HEIGHT);
          ctx.restore();
        }

        if (activeSeason) {
          ctx.save();
          ctx.globalCompositeOperation = 'color-burn';
          ctx.globalAlpha = 0.2;
          if (activeSeason === 'Spring') ctx.fillStyle = '#85B687';
          if (activeSeason === 'Autumn') ctx.fillStyle = '#DFA060';
          if (activeSeason === 'Winter') {
            ctx.globalCompositeOperation = 'saturation';
            ctx.fillStyle = '#222';
            ctx.globalAlpha = 0.4;
          }
          ctx.fillRect(0, 0, WIDTH, HEIGHT);
          ctx.restore();
        }
      }, [activeSeason, activeEffect, drawSingleMountain, drawRiver, drawPaperTexture]);

      const initParticles = useCallback((type) => {
        const arr = [];
        const count = type === 'snow' ? 250 : 200;
        for (let i = 0; i < count; i++) {
          arr.push({
            x: Math.random() * WIDTH,
            y: Math.random() * HEIGHT,
            speed: type === 'snow' ? 0.5 + Math.random() * 0.5 : 8 + Math.random() * 5,
            drift: type === 'snow' ? (Math.random() - 0.5) * 0.5 : 0,
            size: type === 'snow' ? 1 + Math.random() * 2 : 1
          });
        }
        return arr;
      }, []);

      const renderFrame = useCallback(() => {
        const ctx = canvasRef.current?.getContext('2d');
        if (!ctx) return;

        drawScene(ctx);

        if (activeEffect === 'snow') {
          ctx.fillStyle = PALETTE.SNOW;
          for (let i = 0; i < particlesRef.current.length; i++) {
            const p = particlesRef.current[i];
            p.y += p.speed;
            p.x += p.drift;
            if (p.y > HEIGHT) { p.y = -5; p.x = Math.random() * WIDTH; }
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (activeEffect === 'rain') {
          ctx.strokeStyle = PALETTE.RAIN;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          for (let i = 0; i < particlesRef.current.length; i++) {
            const p = particlesRef.current[i];
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x, p.y + 12);
            p.y += p.speed;
            if (p.y > HEIGHT) { p.y = -12; p.x = Math.random() * WIDTH; }
          }
          ctx.stroke();
        }
        animationIntervalRef.current = requestAnimationFrame(renderFrame);
      }, [activeEffect, drawScene]);

      useEffect(() => {
        if (animationIntervalRef.current) cancelAnimationFrame(animationIntervalRef.current);
        if (activeEffect === 'snow') particlesRef.current = initParticles('snow');
        if (activeEffect === 'rain') particlesRef.current = initParticles('rain');

        if (activeEffect) {
          animationIntervalRef.current = requestAnimationFrame(renderFrame);
        } else {
          const ctx = canvasRef.current?.getContext('2d');
          if (ctx) drawScene(ctx);
        }
        return () => cancelAnimationFrame(animationIntervalRef.current);
      }, [activeEffect, renderFrame, initParticles, drawScene]);

      useEffect(() => {
        landscapeDataRef.current = generateLandscapeData();
        if (!activeEffect) {
          const ctx = canvasRef.current?.getContext('2d');
          if (ctx) drawScene(ctx);
        }
      }, [generationKey, generateLandscapeData, activeEffect, drawScene]);

      if (!landscapeDataRef.current) {
        landscapeDataRef.current = generateLandscapeData();
      }

      return <canvas ref={canvasRef} width={WIDTH} height={HEIGHT} className="shadow-2xl max-w-full h-auto border-8 border-white bg-black" />;
    });

    const App = () => {
      const [activeEffect, setActiveEffect] = useState(null);
      const [activeSeason, setActiveSeason] = useState(null);
      const [generationKey, setGenerationKey] = useState(0);
      const [menuOpen, setMenuOpen] = useState(true);

      const handleEffectToggle = (effect) => setActiveEffect(prev => (prev === effect ? null : effect));
      const handleSeasonToggle = (season) => setActiveSeason(prev => (prev === season ? null : season));
      const handleReset = () => { setActiveEffect(null); setActiveSeason(null); };
      const handleRandomize = () => setGenerationKey(prev => prev + 1);

      const handleSave = () => {
        const canvas = document.querySelector('canvas');
        if (!canvas) return;
        const link = document.createElement('a');
        link.download = 'jade-landscape.png';
        link.href = canvas.toDataURL();
        link.click();
      };

      const Button = ({ children, onClick, isActive }) => (
        <button
          onClick={onClick}
          className={`w-[48%] py-2 text-sm rounded border transition duration-300 font-script tracking-wider
            ${isActive
              ? 'bg-slate-800 text-fog border-slate-600 shadow-inner'
              : 'bg-slate-100 text-slate-700 border-slate-300 hover:bg-slate-200'
            }`}
        >
          {children}
        </button>
      );

      return (
        <div className="min-h-[760px] flex flex-col items-center justify-center p-8 bg-gradient-to-br from-slate-900/60 via-slate-900/40 to-emerald-900/30">
          <div className="flex flex-col lg:flex-row gap-10 w-full">
            <div className={`w-full ${menuOpen ? 'lg:w-1/3' : 'lg:w-20'} bg-slate-900/80 p-4 lg:p-6 rounded-xl shadow-2xl border border-slate-800 transition-all duration-300`}>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-display uppercase tracking-[0.25em] text-slate-300">Menu</h3>
                <button
                  onClick={() => setMenuOpen(v => !v)}
                  className="px-3 py-1 text-xs rounded border border-slate-700 text-slate-200 hover:bg-slate-800 transition"
                >
                  {menuOpen ? 'Hide' : 'Show'}
                </button>
              </div>
              {menuOpen && (
              <div className="space-y-8">
              <div className="mb-8 border-b border-slate-700 pb-6">
                <h3 className="text-xl mb-4 font-display uppercase tracking-[0.3em] text-slate-300">Atmosphere</h3>
                <div className="flex flex-wrap gap-3 justify-between">
                  <Button onClick={() => handleEffectToggle('rain')} isActive={activeEffect === 'rain'}>Rain (雨)</Button>
                  <Button onClick={() => handleEffectToggle('snow')} isActive={activeEffect === 'snow'}>Snow (雪)</Button>
                  <Button onClick={() => setActiveEffect(null)} isActive={!activeEffect}>Clear (无)</Button>
                </div>
              </div>

              <div className="mb-8 border-b border-slate-700 pb-6">
                <h3 className="text-xl mb-4 font-display uppercase tracking-[0.3em] text-slate-300">Season</h3>
                <div className="flex flex-wrap gap-3 justify-between">
                  <Button onClick={() => handleSeasonToggle('Spring')} isActive={activeSeason === 'Spring'}>Spring (春)</Button>
                  <Button onClick={() => handleSeasonToggle('Autumn')} isActive={activeSeason === 'Autumn'}>Autumn (秋)</Button>
                  <Button onClick={() => handleSeasonToggle('Winter')} isActive={activeSeason === 'Winter'}>Winter (冬)</Button>
                  <button onClick={handleReset} className="w-[48%] py-2 text-sm rounded border border-red-900 text-red-200 hover:bg-red-900/30 transition">Reset (无)</button>
                </div>
              </div>

              <div>
                <h3 className="text-xl mb-4 font-display uppercase tracking-[0.3em] text-slate-300">Actions</h3>
                <button onClick={handleRandomize} className="w-full py-3 mb-3 text-sm bg-emerald-900 text-emerald-100 rounded hover:bg-emerald-800 transition shadow-lg border border-emerald-700 font-semibold tracking-[0.2em]">
                  RANDOMIZE (重绘)
                </button>
                <button onClick={handleSave} className="w-full py-3 text-sm bg-slate-800 text-slate-200 rounded hover:bg-slate-700 transition shadow border border-slate-700">
                  Save Image (保存)
                </button>
              </div>
              </div>
              )}
            </div>

            <div className={`w-full ${menuOpen ? 'lg:w-2/3' : 'lg:w-full'} flex justify-center items-center bg-slate-950/70 p-4 rounded-xl shadow-inner border border-slate-800 transition-all duration-300`}>
              <LandscapeCanvas activeEffect={activeEffect} activeSeason={activeSeason} generationKey={generationKey} />
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
